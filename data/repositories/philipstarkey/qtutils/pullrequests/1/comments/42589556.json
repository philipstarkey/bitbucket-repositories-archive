{"links": {"self": {"href": "data/repositories/philipstarkey/qtutils/pullrequests/1/comments/42589556.json"}, "html": {"href": "#!/philipstarkey/qtutils/pull-requests/1/_/diff#comment-42589556"}}, "parent": {"id": 42541264, "links": {"self": {"href": "data/repositories/philipstarkey/qtutils/pullrequests/1/comments/42541264.json"}, "html": {"href": "#!/philipstarkey/qtutils/pull-requests/1/_/diff#comment-42541264"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/philipstarkey/qtutils/pullrequests/1.json"}, "html": {"href": "#!/philipstarkey/qtutils/pull-requests/1"}}, "title": "PyQt5"}, "content": {"raw": "it's not too late to add in some mechanism for setting qtutils to use API v1, but it's hard to do in a backward compatible way if we want \"import qtutils.qt\" in a fresh interpreter to be API v2. People using API v1 are mostly doing so by not explicitly setting the API, and we want the default to be API v2, so those two aims are inconsistent.\n\nBackwards compatibility here is hard. Even supporting PyQt4 method calls with patching [may not be reliable](https://github.com/spyder-ide/qtpy/issues/70).\n\nSince qt5 is mostly backward compatible with qt4, I'm starting to wish there was just one PyQt package that went through normal deprecation and feature removal cycles - then we would just get warnings  that code was using deprecated functions, change them one by one and decide on a case by case basis whether to make the patch do a try: except: to keep supporting the old one or not. But, because users upgrading their libraries would be smoother, we'd have little need to support older versions. Just like nobody ever suggested we should support anything but the latest pyqt4 prior to pyqt5 coming out, and just like nobody is suggesting now that we support any pyqt5 other than the latest, or any Python 3 other than the latest. If there's a bug in Qt 5.6, \"upgrade to Qt 5.9\" is considered a reasonable solution. \n\nNow we're left with three or possibly four qt Python wrappers that can't be in the interpreter at the same time, and library code that wants anyone to be able to use it regardless of which wrapper they're using, but which [trips up other code in the interpreter that doesn't know about it](https://github.com/spyder-ide/qtpy/issues/119).\n\nI suppose the break from API 1 to API 2 and the move from QtGui to QtWidgets was sufficiently disruptive to require a major version bump - I hope future changes are less disruptive so that our \"wrapper\" code can revert back to a simple \"if thing in sys.modules import thing, else import preferred thing\".\n\nAnd I've decided against `import *` because not everything starts with `Q`. importing `*` from `QtCore` shadows the builtin `hex()` function (with different behaviour to the builtin)! So importing `*` is not a great way to get around the `QtWidgets`/`QtGui` reshuffle.\n\nSo I don't particularly mind what we do here - I see it as a stop gap, and unlike the Python 2 to 3 transition, very soon nobody is going to be using PyQt4 in extant projects, so our compatibility code helps us ease the transition but afterwards will mostly sit there unused.\n\nHopefully when Qt6 comes around the transition can be done without shim packages. Just like `six` acted as a shim between Python 2 and Python 3, but was mostly made redundant by both Python 2 and Python 3 themselves changing to support the same code running in both using `__future__` imports and the like, hopefully PyQt6 (which is probably not far off, maybe a year or two) will be similar.", "markup": "markdown", "html": "<p>it's not too late to add in some mechanism for setting qtutils to use API v1, but it's hard to do in a backward compatible way if we want \"import qtutils.qt\" in a fresh interpreter to be API v2. People using API v1 are mostly doing so by not explicitly setting the API, and we want the default to be API v2, so those two aims are inconsistent.</p>\n<p>Backwards compatibility here is hard. Even supporting PyQt4 method calls with patching <a data-is-external-link=\"true\" href=\"https://github.com/spyder-ide/qtpy/issues/70\" rel=\"nofollow\">may not be reliable</a>.</p>\n<p>Since qt5 is mostly backward compatible with qt4, I'm starting to wish there was just one PyQt package that went through normal deprecation and feature removal cycles - then we would just get warnings  that code was using deprecated functions, change them one by one and decide on a case by case basis whether to make the patch do a try: except: to keep supporting the old one or not. But, because users upgrading their libraries would be smoother, we'd have little need to support older versions. Just like nobody ever suggested we should support anything but the latest pyqt4 prior to pyqt5 coming out, and just like nobody is suggesting now that we support any pyqt5 other than the latest, or any Python 3 other than the latest. If there's a bug in Qt 5.6, \"upgrade to Qt 5.9\" is considered a reasonable solution. </p>\n<p>Now we're left with three or possibly four qt Python wrappers that can't be in the interpreter at the same time, and library code that wants anyone to be able to use it regardless of which wrapper they're using, but which <a data-is-external-link=\"true\" href=\"https://github.com/spyder-ide/qtpy/issues/119\" rel=\"nofollow\">trips up other code in the interpreter that doesn't know about it</a>.</p>\n<p>I suppose the break from API 1 to API 2 and the move from QtGui to QtWidgets was sufficiently disruptive to require a major version bump - I hope future changes are less disruptive so that our \"wrapper\" code can revert back to a simple \"if thing in sys.modules import thing, else import preferred thing\".</p>\n<p>And I've decided against <code>import *</code> because not everything starts with <code>Q</code>. importing <code>*</code> from <code>QtCore</code> shadows the builtin <code>hex()</code> function (with different behaviour to the builtin)! So importing <code>*</code> is not a great way to get around the <code>QtWidgets</code>/<code>QtGui</code> reshuffle.</p>\n<p>So I don't particularly mind what we do here - I see it as a stop gap, and unlike the Python 2 to 3 transition, very soon nobody is going to be using PyQt4 in extant projects, so our compatibility code helps us ease the transition but afterwards will mostly sit there unused.</p>\n<p>Hopefully when Qt6 comes around the transition can be done without shim packages. Just like <code>six</code> acted as a shim between Python 2 and Python 3, but was mostly made redundant by both Python 2 and Python 3 themselves changing to support the same code running in both using <code>__future__</code> imports and the like, hopefully PyQt6 (which is probably not far off, maybe a year or two) will be similar.</p>", "type": "rendered"}, "created_on": "2017-08-10T15:26:40.549186+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-08-10T15:26:40.552841+00:00", "type": "pullrequest_comment", "id": 42589556}