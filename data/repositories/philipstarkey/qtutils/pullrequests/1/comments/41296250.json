{"links": {"self": {"href": "data/repositories/philipstarkey/qtutils/pullrequests/1/comments/41296250.json"}, "html": {"href": "#!/philipstarkey/qtutils/pull-requests/1/_/diff#comment-41296250"}}, "parent": {"id": 41295683, "links": {"self": {"href": "data/repositories/philipstarkey/qtutils/pullrequests/1/comments/41295683.json"}, "html": {"href": "#!/philipstarkey/qtutils/pull-requests/1/_/diff#comment-41295683"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/philipstarkey/qtutils/pullrequests/1.json"}, "html": {"href": "#!/philipstarkey/qtutils/pull-requests/1"}}, "title": "PyQt5"}, "content": {"raw": "Lol at correcting my German grammar :P\n\nLowercase `qt` sounds good to disambiguate even if you're not doing `import *`, because really this `qt` module is standing in for `PyQt4` etc, definitely not the `Qt` submodule of them, and despite namespacing people will definitely confuse this.\n\nA few more comments:\n\n**1.** In `Qt.py` (to presumably be renamed `qt.py`), you should probably inspect `sys.modules` to see if there is a Qt module already imported, and use it if it is. Only after that would you fall back to importing one yourself. Something like this:\n\n\n```\n#!python\n\nlibs = [PYQT5, PYQT4, PYSIDE]\nfor lib in libs:\n    if lib in sys.modules:\n        # A Qt module has already been imported, use it:\n        QT_ENV = lib\n        break\nelse:\n    for lib in libs:\n        try:\n            __import__(lib)\n            QT_ENV = lib\n            break\n        except ImportError:\n            pass\n```\n(for the unaware: an \"else\" clause after a for loop is valid sytax - it means \"run this code if the loop completes without breaking\")\n\nThat way qtutils will never import an additional Qt module if one is already imported.\n\n** 2.** Every other file in qtutils with qt imports at the top should now use the abstraction layer. At the moment they have a different priority order - they prefer pyside, then pyqt4, then pyqt5, and different logic - checking if Pyside is in sys.modules, and then deciding between PyQt4 and PyQt5 based on an import error (rather than checking if either is in sys.modules). More important than what the exact logic is is making sure we have it in one place. So all the other modules' import lines should use the abstraction layer like this instead (or whatever is relevant to them):\n\n\n```\n#!python\nfrom qtutils.qt.QtCore import *\nfrom qtutils.qt.QtGui import *\nfrom qtutils.qt.QtWidgets import *\n```\nAny remaining places where you need to choose which Qt library to import, in a way that isn't covered by the abstraction layer, such as:\n\n```\n#!python\n\n    try:\n        from PyQt4 import uic\n    except ImportError:\n        from PyQt5 import uic\n```\nin the UI loader file, should instead import `qtutils.qt` and then inspect the `QT_ENV` variable to decide what to do. Also, whenever you find yourself doing that, you should think whether the logic should be moved into the abstraction layer or not (it's not always the case that it should be, for example this `uic` submodule exists in PyQt 4 and 5 but not PySide, so it probably doesn't belong in the abstraction layer - the ui loader file actually *is* the abstraction layer for this).\n\n** 3.**  Doesn't the API setting have to take place before importing PyQt in `__init__.py`? What I would suggest is to make `__init__.py` import the abstraction layer before setting the message handler, and to move the API setting to the abstraction layer, something like this in `Qt.py` (untested but this is the general idea):\n\n```\n#!python\n\ndef set_pyqt4_API2():\n    import sip\n    # This must be done before importing PyQt4:\n    API_NAMES = [\"QDate\", \"QDateTime\", \"QString\", \"QTextStream\", \"QTime\", \"QUrl\", \"QVariant\"]\n    API_VERSION = 2\n    for name in API_NAMES:\n        try:\n            sip.setapi(name, API_VERSION)\n        except ValueError:\n            pass\n\ndef check_pyqt4_api():\n    \"\"\"If PyQt4 was already imported before we got a chance to set API version 2, ensure the API\n    versions were already set to version 2. Otherwise confusing errors may occur later - better to catch this now\"\"\"\n    API_NAMES = [\"QDate\", \"QDateTime\", \"QString\", \"QTextStream\", \"QTime\", \"QUrl\", \"QVariant\"]\n    API_VERSION = 2\n    for name in API_NAMES:\n        try:\n            if sip.getapi(name) != API_VERSION\n            raise RuntimeError(\"qtutils only compatible with version 2 of the  PYQt4 API. Either set the API to version 2 before importing PyQt4, or import qtutils first, which will set it for you\")\n        except ValueError:\n            pass\n\nlibs = [PYQT5, PYQT4, PYSIDE]\nfor lib in libs:\n    if lib in sys.modules:\n        QT_ENV = lib\n        if lib == PYQT4:\n            check_pyqt4_api()\n        break\nelse:\n    for lib in libs:\n        if lib == PYQT4:\n             # Have to set pyqt API v2 before importing PyQt4:\n             set_pyqt4_API2()\n        try:\n            __import__(lib)\n            QT_ENV = lib\n            break\n        except ImportError:\n            pass\n```\n\n**4.** `qtutils/icons/_build.py` and `setup.py` appear to have been converted to 2 spaces for indentation instead of 4. Should definitely be four spaces! I assume this was a misconfigured PEP8 conversion.", "markup": "markdown", "html": "<p>Lol at correcting my German grammar :P</p>\n<p>Lowercase <code>qt</code> sounds good to disambiguate even if you're not doing <code>import *</code>, because really this <code>qt</code> module is standing in for <code>PyQt4</code> etc, definitely not the <code>Qt</code> submodule of them, and despite namespacing people will definitely confuse this.</p>\n<p>A few more comments:</p>\n<p><strong>1.</strong> In <code>Qt.py</code> (to presumably be renamed <code>qt.py</code>), you should probably inspect <code>sys.modules</code> to see if there is a Qt module already imported, and use it if it is. Only after that would you fall back to importing one yourself. Something like this:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">libs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">PYQT5</span><span class=\"p\">,</span> <span class=\"n\">PYQT4</span><span class=\"p\">,</span> <span class=\"n\">PYSIDE</span><span class=\"p\">]</span>\n<span class=\"k\">for</span> <span class=\"n\">lib</span> <span class=\"ow\">in</span> <span class=\"n\">libs</span><span class=\"p\">:</span>\n    <span class=\"k\">if</span> <span class=\"n\">lib</span> <span class=\"ow\">in</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">modules</span><span class=\"p\">:</span>\n        <span class=\"c1\"># A Qt module has already been imported, use it:</span>\n        <span class=\"n\">QT_ENV</span> <span class=\"o\">=</span> <span class=\"n\">lib</span>\n        <span class=\"k\">break</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">lib</span> <span class=\"ow\">in</span> <span class=\"n\">libs</span><span class=\"p\">:</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"nb\">__import__</span><span class=\"p\">(</span><span class=\"n\">lib</span><span class=\"p\">)</span>\n            <span class=\"n\">QT_ENV</span> <span class=\"o\">=</span> <span class=\"n\">lib</span>\n            <span class=\"k\">break</span>\n        <span class=\"k\">except</span> <span class=\"ne\">ImportError</span><span class=\"p\">:</span>\n            <span class=\"k\">pass</span>\n</pre></div>\n\n\n<p>(for the unaware: an \"else\" clause after a for loop is valid sytax - it means \"run this code if the loop completes without breaking\")</p>\n<p>That way qtutils will never import an additional Qt module if one is already imported.</p>\n<p><strong> 2.</strong> Every other file in qtutils with qt imports at the top should now use the abstraction layer. At the moment they have a different priority order - they prefer pyside, then pyqt4, then pyqt5, and different logic - checking if Pyside is in sys.modules, and then deciding between PyQt4 and PyQt5 based on an import error (rather than checking if either is in sys.modules). More important than what the exact logic is is making sure we have it in one place. So all the other modules' import lines should use the abstraction layer like this instead (or whatever is relevant to them):</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">qtutils.qt.QtCore</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"kn\">from</span> <span class=\"nn\">qtutils.qt.QtGui</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"kn\">from</span> <span class=\"nn\">qtutils.qt.QtWidgets</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n</pre></div>\n\n\n<p>Any remaining places where you need to choose which Qt library to import, in a way that isn't covered by the abstraction layer, such as:</p>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"kn\">from</span> <span class=\"nn\">PyQt4</span> <span class=\"kn\">import</span> <span class=\"n\">uic</span>\n    <span class=\"k\">except</span> <span class=\"ne\">ImportError</span><span class=\"p\">:</span>\n        <span class=\"kn\">from</span> <span class=\"nn\">PyQt5</span> <span class=\"kn\">import</span> <span class=\"n\">uic</span>\n</pre></div>\n\n\n<p>in the UI loader file, should instead import <code>qtutils.qt</code> and then inspect the <code>QT_ENV</code> variable to decide what to do. Also, whenever you find yourself doing that, you should think whether the logic should be moved into the abstraction layer or not (it's not always the case that it should be, for example this <code>uic</code> submodule exists in PyQt 4 and 5 but not PySide, so it probably doesn't belong in the abstraction layer - the ui loader file actually <em>is</em> the abstraction layer for this).</p>\n<p><strong> 3.</strong>  Doesn't the API setting have to take place before importing PyQt in <code>__init__.py</code>? What I would suggest is to make <code>__init__.py</code> import the abstraction layer before setting the message handler, and to move the API setting to the abstraction layer, something like this in <code>Qt.py</code> (untested but this is the general idea):</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">set_pyqt4_API2</span><span class=\"p\">():</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">sip</span>\n    <span class=\"c1\"># This must be done before importing PyQt4:</span>\n    <span class=\"n\">API_NAMES</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">&quot;QDate&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QDateTime&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QString&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QTextStream&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QTime&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QUrl&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QVariant&quot;</span><span class=\"p\">]</span>\n    <span class=\"n\">API_VERSION</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n    <span class=\"k\">for</span> <span class=\"n\">name</span> <span class=\"ow\">in</span> <span class=\"n\">API_NAMES</span><span class=\"p\">:</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">sip</span><span class=\"o\">.</span><span class=\"n\">setapi</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">API_VERSION</span><span class=\"p\">)</span>\n        <span class=\"k\">except</span> <span class=\"ne\">ValueError</span><span class=\"p\">:</span>\n            <span class=\"k\">pass</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">check_pyqt4_api</span><span class=\"p\">():</span>\n    <span class=\"sd\">&quot;&quot;&quot;If PyQt4 was already imported before we got a chance to set API version 2, ensure the API</span>\n<span class=\"sd\">    versions were already set to version 2. Otherwise confusing errors may occur later - better to catch this now&quot;&quot;&quot;</span>\n    <span class=\"n\">API_NAMES</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">&quot;QDate&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QDateTime&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QString&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QTextStream&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QTime&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QUrl&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;QVariant&quot;</span><span class=\"p\">]</span>\n    <span class=\"n\">API_VERSION</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n    <span class=\"k\">for</span> <span class=\"n\">name</span> <span class=\"ow\">in</span> <span class=\"n\">API_NAMES</span><span class=\"p\">:</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">sip</span><span class=\"o\">.</span><span class=\"n\">getapi</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"n\">API_VERSION</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">RuntimeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;qtutils only compatible with version 2 of the  PYQt4 API. Either set the API to version 2 before importing PyQt4, or import qtutils first, which will set it for you&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">except</span> <span class=\"ne\">ValueError</span><span class=\"p\">:</span>\n            <span class=\"k\">pass</span>\n\n<span class=\"n\">libs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">PYQT5</span><span class=\"p\">,</span> <span class=\"n\">PYQT4</span><span class=\"p\">,</span> <span class=\"n\">PYSIDE</span><span class=\"p\">]</span>\n<span class=\"k\">for</span> <span class=\"n\">lib</span> <span class=\"ow\">in</span> <span class=\"n\">libs</span><span class=\"p\">:</span>\n    <span class=\"k\">if</span> <span class=\"n\">lib</span> <span class=\"ow\">in</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">modules</span><span class=\"p\">:</span>\n        <span class=\"n\">QT_ENV</span> <span class=\"o\">=</span> <span class=\"n\">lib</span>\n        <span class=\"k\">if</span> <span class=\"n\">lib</span> <span class=\"o\">==</span> <span class=\"n\">PYQT4</span><span class=\"p\">:</span>\n            <span class=\"n\">check_pyqt4_api</span><span class=\"p\">()</span>\n        <span class=\"k\">break</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">lib</span> <span class=\"ow\">in</span> <span class=\"n\">libs</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">lib</span> <span class=\"o\">==</span> <span class=\"n\">PYQT4</span><span class=\"p\">:</span>\n             <span class=\"c1\"># Have to set pyqt API v2 before importing PyQt4:</span>\n             <span class=\"n\">set_pyqt4_API2</span><span class=\"p\">()</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"nb\">__import__</span><span class=\"p\">(</span><span class=\"n\">lib</span><span class=\"p\">)</span>\n            <span class=\"n\">QT_ENV</span> <span class=\"o\">=</span> <span class=\"n\">lib</span>\n            <span class=\"k\">break</span>\n        <span class=\"k\">except</span> <span class=\"ne\">ImportError</span><span class=\"p\">:</span>\n            <span class=\"k\">pass</span>\n</pre></div>\n\n\n<p><strong>4.</strong> <code>qtutils/icons/_build.py</code> and <code>setup.py</code> appear to have been converted to 2 spaces for indentation instead of 4. Should definitely be four spaces! I assume this was a misconfigured PEP8 conversion.</p>", "type": "rendered"}, "created_on": "2017-07-22T17:45:23.339331+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-07-22T17:48:04.085050+00:00", "type": "pullrequest_comment", "id": 41296250}