{"rendered": {"message": {"raw": "Modified invoke_in_main to not \"leak\" memory\n\nI put \"leak\" in quotes because it is yet unclear whether it actually does leak memory. What we do know is that the memory usage of a program using the in_main function does grow, but periodically it drops significantly. Longer testing must be done before we can tell whether we actually have a memory leak.\n\nHowever, I have discovered that the Qt documentation states that an event passed to QCoreApplication.postEvent() should not be accessed after it is posted. We were accessing it to wait for the event to be processed. When we don't access it after calling QCoreApplication.postEvent() (and instead pass in a queue at event instantiation, which we then wait on), the memory usage does not grow nearly as rapidly and from preliminary observations, oscialltes around an average usage.\n\nFurther testing will ensue.", "markup": "markdown", "html": "<p>Modified invoke_in_main to not \"leak\" memory</p>\n<p>I put \"leak\" in quotes because it is yet unclear whether it actually does leak memory. What we do know is that the memory usage of a program using the in_main function does grow, but periodically it drops significantly. Longer testing must be done before we can tell whether we actually have a memory leak.</p>\n<p>However, I have discovered that the Qt documentation states that an event passed to QCoreApplication.postEvent() should not be accessed after it is posted. We were accessing it to wait for the event to be processed. When we don't access it after calling QCoreApplication.postEvent() (and instead pass in a queue at event instantiation, which we then wait on), the memory usage does not grow nearly as rapidly and from preliminary observations, oscialltes around an average usage.</p>\n<p>Further testing will ensue.</p>", "type": "rendered"}}, "hash": "65d006d40bf3ca54efb21ad27ad711f2fc7dc717", "repository": {"links": {"self": {"href": "data/repositories/pstarkey/qtutils-dev.json"}, "html": {"href": "#!/pstarkey/qtutils-dev"}, "avatar": {"href": "data/bytebucket.org/ravatar/{916b6aa5-ce08-4c6a-a893-abea22e41679}ts=python"}}, "type": "repository", "name": "qtutils-dev", "full_name": "pstarkey/qtutils-dev", "uuid": "{916b6aa5-ce08-4c6a-a893-abea22e41679}"}, "links": {"self": {"href": "data/repositories/pstarkey/qtutils-dev/commit/65d006d40bf3ca54efb21ad27ad711f2fc7dc717.json"}, "comments": {"href": "data/repositories/pstarkey/qtutils-dev/commit/65d006d40bf3ca54efb21ad27ad711f2fc7dc717/comments_page=1.json"}, "patch": {"href": "https://api.bitbucket.org/2.0/repositories/pstarkey/qtutils-dev/patch/65d006d40bf3ca54efb21ad27ad711f2fc7dc717"}, "html": {"href": "#!/pstarkey/qtutils-dev/commits/65d006d40bf3ca54efb21ad27ad711f2fc7dc717"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/pstarkey/qtutils-dev/diff/65d006d40bf3ca54efb21ad27ad711f2fc7dc717"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/pstarkey/qtutils-dev/commit/65d006d40bf3ca54efb21ad27ad711f2fc7dc717/approve"}, "statuses": {"href": "data/repositories/pstarkey/qtutils-dev/commit/65d006d40bf3ca54efb21ad27ad711f2fc7dc717/statuses_page=1.json"}}, "author": {"raw": "pstarkey", "type": "author", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}}, "summary": {"raw": "Modified invoke_in_main to not \"leak\" memory\n\nI put \"leak\" in quotes because it is yet unclear whether it actually does leak memory. What we do know is that the memory usage of a program using the in_main function does grow, but periodically it drops significantly. Longer testing must be done before we can tell whether we actually have a memory leak.\n\nHowever, I have discovered that the Qt documentation states that an event passed to QCoreApplication.postEvent() should not be accessed after it is posted. We were accessing it to wait for the event to be processed. When we don't access it after calling QCoreApplication.postEvent() (and instead pass in a queue at event instantiation, which we then wait on), the memory usage does not grow nearly as rapidly and from preliminary observations, oscialltes around an average usage.\n\nFurther testing will ensue.", "markup": "markdown", "html": "<p>Modified invoke_in_main to not \"leak\" memory</p>\n<p>I put \"leak\" in quotes because it is yet unclear whether it actually does leak memory. What we do know is that the memory usage of a program using the in_main function does grow, but periodically it drops significantly. Longer testing must be done before we can tell whether we actually have a memory leak.</p>\n<p>However, I have discovered that the Qt documentation states that an event passed to QCoreApplication.postEvent() should not be accessed after it is posted. We were accessing it to wait for the event to be processed. When we don't access it after calling QCoreApplication.postEvent() (and instead pass in a queue at event instantiation, which we then wait on), the memory usage does not grow nearly as rapidly and from preliminary observations, oscialltes around an average usage.</p>\n<p>Further testing will ensue.</p>", "type": "rendered"}, "participants": [], "parents": [{"hash": "4eea298d2c5dab654916adf8a4aefb59853e0a2d", "type": "commit", "links": {"self": {"href": "data/repositories/pstarkey/qtutils-dev/commit/4eea298d2c5dab654916adf8a4aefb59853e0a2d.json"}, "html": {"href": "#!/pstarkey/qtutils-dev/commits/4eea298d2c5dab654916adf8a4aefb59853e0a2d"}}}], "date": "2013-11-11T23:27:42+00:00", "message": "Modified invoke_in_main to not \"leak\" memory\n\nI put \"leak\" in quotes because it is yet unclear whether it actually does leak memory. What we do know is that the memory usage of a program using the in_main function does grow, but periodically it drops significantly. Longer testing must be done before we can tell whether we actually have a memory leak.\n\nHowever, I have discovered that the Qt documentation states that an event passed to QCoreApplication.postEvent() should not be accessed after it is posted. We were accessing it to wait for the event to be processed. When we don't access it after calling QCoreApplication.postEvent() (and instead pass in a queue at event instantiation, which we then wait on), the memory usage does not grow nearly as rapidly and from preliminary observations, oscialltes around an average usage.\n\nFurther testing will ensue.", "type": "commit", "git_hash": "de5819113f7fad69db0bc39ade6f08b0e413692f", "tags": null, "branches": "default"}